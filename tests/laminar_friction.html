<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic Laminar Flow: The Friction Model</title>
    <!-- React & Tailwind -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Sliders */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 0 2px #1e293b; 
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
        input[type=range]:focus { outline: none; }
        
        .canvas-container {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            overflow: hidden;
            background: #1e293b;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- SOLVER CONFIG ---
        const GRID_SIZE = 50; // Number of fluid layers
        const DT = 0.05;      // Time step

        // --- COMPONENTS ---

        // Simple KaTeX Wrapper (MISSING BEFORE)
        const Latex = ({ children, block = false }) => {
            const containerRef = useRef(null);
            useEffect(() => {
                if (window.katex && containerRef.current) {
                    window.katex.render(children, containerRef.current, {
                        throwOnError: false,
                        displayMode: block
                    });
                }
            }, [children, block]);
            return <span ref={containerRef} />;
        };

        const Slider = ({ label, value, min, max, step, onChange, unit }) => (
            <div className="flex flex-col mb-4 group">
                <div className="flex justify-between mb-1">
                    <label className="text-sm font-medium text-slate-300 group-hover:text-blue-300 transition-colors">{label}</label>
                    <span className="text-sm text-slate-400 font-mono">{Number.isInteger(value) ? value : value.toFixed(1)} {unit}</span>
                </div>
                <input 
                    type="range" 
                    min={min} max={max} step={step} 
                    value={value} 
                    onChange={(e) => onChange(parseFloat(e.target.value))}
                    className="w-full"
                />
            </div>
        );

        const Toggle = ({ label, checked, onChange }) => (
            <div className="flex items-center justify-between mb-4 p-2 bg-slate-900/50 rounded cursor-pointer hover:bg-slate-900 transition-colors" onClick={() => onChange(!checked)}>
                <label className="text-sm font-medium text-slate-300 cursor-pointer">{label}</label>
                <div className={`w-10 h-5 rounded-full relative transition-colors ${checked ? 'bg-blue-600' : 'bg-slate-600'}`}>
                    <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${checked ? 'left-6' : 'left-1'}`}></div>
                </div>
            </div>
        );

        // --- MAIN APP ---

        const LaminarFriction = () => {
            // -- Controls --
            const [pressure, setPressure] = useState(2.0);    // The "Push"
            const [viscosity, setViscosity] = useState(1.0);  // The "Drag" strength
            const [wallFriction, setWallFriction] = useState(true); // "No-Slip" Condition
            
            // -- Simulation State --
            // We use refs for physics state to avoid React render loop overhead
            const stateRef = useRef({
                // Velocity Grid: v[0] is top wall, v[GRID_SIZE-1] is bottom wall
                velocities: new Array(GRID_SIZE).fill(0),
                particles: [] 
            });

            // Refs for rendering
            const canvasRef = useRef(null);
            const requestIdRef = useRef(null);

            // Initialize Particles
            useEffect(() => {
                const parts = [];
                for(let i=0; i<400; i++) {
                    parts.push({
                        x: Math.random() * window.innerWidth,
                        yLayer: Math.random() * (GRID_SIZE - 1), // Continuous vertical position
                        speed: 0
                    });
                }
                stateRef.current.particles = parts;
            }, []);

            // --- 1. THE SOLVER: MOMENTUM DIFFUSION ---
            // This replaces the parabola equation. It calculates flow layer by layer.
            const solveFluid = () => {
                const v = stateRef.current.velocities;
                const N = GRID_SIZE;
                const newV = [...v]; // Temp array for next step

                // Physics Constants
                // Diffusion coefficient ~ viscosity
                // Stability requires nu * dt / dx^2 < 0.5. Let's just tune factor directly.
                const diffusionFactor = (viscosity * 0.1); 
                const pushForce = pressure * 0.1;

                // For each layer (excluding walls for now)
                for (let i = 1; i < N - 1; i++) {
                    // 1. Viscous Drag (Diffusion)
                    // The neighbor pulling logic: (Left + Right - 2*Center)
                    // If neighbor is faster, it pulls me forward. If slower, drags me back.
                    const neighborDrag = (v[i-1] + v[i+1] - 2*v[i]);
                    
                    // 2. Update Velocity
                    // Acceleration = (Drag Force + Push Force)
                    // v_new = v_old + (Diffusion + Pressure) * dt
                    newV[i] = v[i] + (neighborDrag * diffusionFactor + pushForce) * DT;
                    
                    // Simple damping/drag to prevent infinite acceleration (simulating tube length resistance)
                    newV[i] *= 0.99; 
                }

                // --- BOUNDARY CONDITIONS (THE ATOMIC IDEA) ---
                if (wallFriction) {
                    // No-Slip: Fluid at wall STOPS.
                    newV[0] = 0;
                    newV[N-1] = 0;
                } else {
                    // Slip: Walls are ice. No friction.
                    // Derivative is 0 (Neumann BC), or just let them slide freely
                    // Let's model "partial slip" or just free slip -> same as neighbor
                    newV[0] = newV[1];
                    newV[N-1] = newV[N-2];
                }

                stateRef.current.velocities = newV;
            };

            // --- RENDER LOOP ---
            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;

                // Run Physics
                solveFluid();
                solveFluid(); // Multiple substeps for stability/speed

                // Clear
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                // Dimensions
                const layerH = h / GRID_SIZE;
                const v = stateRef.current.velocities;
                const maxDisplayV = 20; // For scaling visuals

                // 1. Draw Background Grid (Layers)
                v.forEach((vel, i) => {
                    const y = i * layerH;
                    
                    // Calculate Shear (Slope)
                    let shear = 0;
                    if (i > 0 && i < GRID_SIZE-1) {
                        shear = Math.abs(v[i+1] - v[i-1]);
                    } else if (i === 0) shear = Math.abs(v[1] - v[0]);
                    
                    // Visualize Shear Stress as opacity/color
                    // High shear (near walls) = Redder
                    // Low shear (center) = Bluer
                    const shearNorm = Math.min(shear * 2, 1);
                    const r = Math.floor(shearNorm * 255);
                    const b = Math.floor((1-shearNorm) * 255);
                    
                    ctx.fillStyle = `rgba(${r}, 50, ${b}, 0.15)`; 
                    ctx.fillRect(0, y, w, layerH);

                    // Divider line
                    ctx.strokeStyle = `rgba(148, 163, 184, 0.05)`;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                });

                // 2. Draw Particles
                ctx.fillStyle = '#60a5fa';
                stateRef.current.particles.forEach(p => {
                    // Get velocity from grid (linear interpolate)
                    const layerIdx = Math.floor(p.yLayer);
                    const subLayer = p.yLayer - layerIdx;
                    
                    let currentV = 0;
                    if (layerIdx >= 0 && layerIdx < GRID_SIZE - 1) {
                         currentV = v[layerIdx] * (1-subLayer) + v[layerIdx+1] * subLayer;
                    }
                    
                    // Move
                    p.x += currentV * 2; 
                    if (p.x > w) p.x = 0;

                    // Draw
                    const yPos = p.yLayer * layerH;
                    // Size scales slightly with speed for effect
                    const size = 2 + (currentV / maxDisplayV) * 2;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, yPos, size, 0, Math.PI * 2);
                    ctx.fill();
                });

                // 3. Draw Velocity Profile (Pink Line)
                ctx.strokeStyle = '#f472b6'; 
                ctx.lineWidth = 3;
                ctx.beginPath();
                const centerX = w / 2;
                
                v.forEach((vel, i) => {
                    const y = i * layerH + layerH/2;
                    const x = centerX + (vel * 10); 
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // 4. Draw Shear Stress Profile (Yellow Line - NEW)
                // This shows the derivative dv/dy
                if (wallFriction) {
                    ctx.strokeStyle = '#facc15'; // Yellow
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    
                    v.forEach((vel, i) => {
                        const y = i * layerH + layerH/2;
                        
                        let slope = 0;
                        if (i < GRID_SIZE-1) slope = Math.abs(v[i+1] - v[i]);
                        
                        // Scale slope for visibility
                        // Slope is max at walls, 0 at center
                        const x = centerX - 100 + (slope * 100); 
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label for Shear Graph
                    ctx.fillStyle = '#facc15';
                    ctx.font = '10px sans-serif';
                    ctx.fillText("Shear Stress (τ)", centerX - 100, 20);
                }

                // 5. Draw Wall Annotations
                ctx.fillStyle = wallFriction ? '#ef4444' : '#10b981'; 
                ctx.fillRect(0, 0, w, layerH); // Top Wall
                ctx.fillRect(0, h - layerH, w, layerH); // Bottom Wall
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(wallFriction ? "WALL: NO SLIP (v=0)" : "WALL: SLIPPERY (v=free)", 10, 15);
                ctx.fillText(wallFriction ? "WALL: FRICTION" : "WALL: SLIPPERY", 10, h - 5);


                requestIdRef.current = requestAnimationFrame(draw);
            };

            // Init Loop
            useEffect(() => {
                const handleResize = () => {
                    if (canvasRef.current) {
                        canvasRef.current.width = canvasRef.current.parentElement.offsetWidth;
                        canvasRef.current.height = 400;
                    }
                };
                window.addEventListener('resize', handleResize);
                handleResize();

                requestIdRef.current = requestAnimationFrame(draw);
                return () => cancelAnimationFrame(requestIdRef.current);
            }, [wallFriction]); // restart loop if needed, though refs handle state

            return (
                <div className="max-w-6xl mx-auto p-4 md:p-8">
                    <header className="mb-8">
                        <h1 className="text-4xl font-extrabold text-white mb-2">Atomic Laminar Flow</h1>
                        <p className="text-slate-400 text-lg">
                            Building the parabola from scratch: <span className="text-blue-400 font-bold">Friction</span> + <span className="text-emerald-400 font-bold">Neighbor Drag</span>.
                        </p>
                    </header>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        {/* LEFT: CONTROLS & EXPLANATION */}
                        <div className="space-y-6">
                            <div className="bg-slate-800 p-6 rounded-xl border border-slate-700">
                                <h2 className="text-xl font-bold text-white mb-6 border-b border-slate-700 pb-2">The Setup</h2>
                                
                                <Slider label="1. The Push (Pressure)" value={pressure} min={0} max={10} step={0.1} unit="" onChange={setPressure} />
                                <p className="text-xs text-slate-500 mb-6">Pushes all fluid forward equally.</p>

                                <Toggle label="2. The Wall (Boundary)" checked={wallFriction} onChange={setWallFriction} />
                                <p className="text-xs text-slate-500 mb-6">
                                    {wallFriction 
                                        ? "Fluid touching wall is forced to STOP." 
                                        : "Fluid slides freely. No anchor."}
                                </p>

                                <Slider label="3. The Drag (Viscosity)" value={viscosity} min={0.1} max={5.0} step={0.1} unit="" onChange={setViscosity} />
                                <p className="text-xs text-slate-500">How strongly fluid layers pull their neighbors.</p>
                            </div>

                            <div className="bg-slate-900 p-6 rounded-xl border border-slate-800">
                                <h3 className="text-blue-400 font-bold uppercase text-xs tracking-wider mb-3">What to look for</h3>
                                <ul className="space-y-3 text-sm text-slate-300">
                                    <li className="flex gap-2">
                                        <span className="text-red-400 font-bold">1.</span>
                                        <span>Turn <strong>The Wall</strong> OFF. Notice the fluid moves as a solid block (Plug Flow). Why? Nothing slows the edges.</span>
                                    </li>
                                    <li className="flex gap-2">
                                        <span className="text-emerald-400 font-bold">2.</span>
                                        <span>Turn <strong>The Wall</strong> ON. Watch the edges stop immediately.</span>
                                    </li>
                                    <li className="flex gap-2">
                                        <span className="text-blue-400 font-bold">3.</span>
                                        <span>Watch the "Stop" signal travel inward. This is <strong>momentum diffusion</strong>. The center doesn't know the wall exists yet!</span>
                                    </li>
                                    <li className="flex gap-2">
                                        <span className="text-amber-400 font-bold">4.</span>
                                        <span>Eventually, it settles into a curve. The curve is just the balance between "Pushing Forward" and "Dragging Back".</span>
                                    </li>
                                </ul>
                            </div>
                        </div>

                        {/* RIGHT: SIMULATION */}
                        <div className="lg:col-span-2">
                            <div className="canvas-container relative">
                                <canvas ref={canvasRef} className="block w-full bg-slate-900"></canvas>
                                
                                {/* Overlay Labels */}
                                <div className="absolute top-1/2 left-4 transform -translate-y-1/2 text-center pointer-events-none">
                                    <div className="text-xs font-bold text-white bg-slate-800/80 px-2 py-1 rounded mb-1">Inlet</div>
                                    <div className="text-2xl text-white">→</div>
                                </div>
                            </div>
                            
                            <div className="mt-4 flex justify-between text-xs text-slate-500 font-mono">
                                <div>Wall (v=0)</div>
                                <div>Center (v=max)</div>
                                <div>Wall (v=0)</div>
                            </div>

                            {/* MATH BREAKDOWN SECTION */}
                            <div className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
                                {/* CARD 1: MOMENTUM BALANCE */}
                                <div className="bg-slate-800 p-4 rounded-lg border border-slate-700">
                                    <h4 className="text-sm font-bold text-white mb-2 flex items-center gap-2">
                                        <span className="w-2 h-2 rounded-full bg-blue-500"></span>
                                        Force Balance
                                    </h4>
                                    <div className="text-center py-4 bg-slate-900 rounded mb-3 font-mono text-sm text-slate-300">
                                        <Latex>{`F_{net} = F_{push} - F_{drag}`}</Latex>
                                    </div>
                                    <p className="text-xs text-slate-400 leading-relaxed">
                                        Every fluid layer accelerates until the <strong>Push</strong> (Pressure) is exactly balanced by the <strong>Drag</strong> from its slower neighbor.
                                        <br/><br/>
                                        When <Latex>{`F_{net} = 0`}</Latex>, the velocity stabilizes (Steady State).
                                    </p>
                                </div>

                                {/* CARD 2: SHEAR STRESS */}
                                <div className="bg-slate-800 p-4 rounded-lg border border-slate-700">
                                    <h4 className="text-sm font-bold text-white mb-2 flex items-center gap-2">
                                        <span className="w-2 h-2 rounded-full bg-emerald-500"></span>
                                        Newton's Law of Viscosity
                                    </h4>
                                    <div className="text-center py-4 bg-slate-900 rounded mb-3 font-mono text-sm text-slate-300">
                                        <Latex>{`\\tau = \\eta \\cdot \\frac{dv}{dy}`}</Latex>
                                    </div>
                                    <p className="text-xs text-slate-400 leading-relaxed">
                                        <strong>Shear Stress (<Latex>{`\\tau`}</Latex>)</strong> is the friction force.
                                        <br/>
                                        It depends on <strong>Viscosity (<Latex>{`\\eta`}</Latex>)</strong> and how fast velocity changes with distance (<Latex>{`dv/dy`}</Latex>).
                                        <br/><br/>
                                        Steep slope = High friction.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LaminarFriction />);
    </script>
</body>
</html>

